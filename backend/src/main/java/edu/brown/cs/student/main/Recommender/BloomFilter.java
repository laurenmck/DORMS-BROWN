package edu.brown.cs.student.main.Recommender;

import java.math.BigInteger;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.BitSet;
import java.util.Collection;
import java.util.Objects;

import static java.lang.Math.ceil;
import static java.lang.Math.log;

/**
 * Bloom Filter class.
 * In this class, we can create an empty Generic Bloom Filter,
 * add elements to it, and query elements from it.
 *
 * @param <T> type of elements contained in the bloom filter.
 *            For example, T can be String or Integer
 */
public class BloomFilter<T> {

  /**
   * false positivity rate.
   */
  private final Double r;

  /**
   * maximum number of elements that can be added to the bloom filter.
   */
  private final Integer n;

  /**
   * actual number of elements added to the bloom filter.
   */
  private Integer numElements;

  /**
   * used to store bit array.
   */
  private final BitSet bitSet;

  /**
   * number of bits in bitSet.
   */
  private final Integer m;

  /**
   * number of hash functions.
   */
  private final Integer k;

  // The values below are used in the stencil code to create hashes.
  private static final Charset CHARSET = StandardCharsets.UTF_8;
  private static MessageDigest hashFunction;

  static {
    try {
      hashFunction = MessageDigest.getInstance("SHA1");
    } catch (NoSuchAlgorithmException e) {
      System.out.println("ERROR: " + e.getMessage());
    }
  }

  private static final int HEX_VALUE_255 = 0xFF;
  private static final int HEX_VALUE_15 = 0x0F;
  private static final int RADIX = 16;

  /**
   * Construct an empty bloom filter given a false positivity rate and a maximum number of elements.
   *
   * @param r false positivity rate
   * @param n maximum number of elements that can be added to the bloom filter
   */
  public BloomFilter(Double r, Integer n) {
    this.numElements = 0;
    this.r = r;
    this.n = n;
    this.k = (int) ceil(-log(r) / log(2));
    this.m = (int) ceil(k * n / log(2));
    this.bitSet = new BitSet(m);
  }

  /**
   * Gives the Bloom filter's BitSet.
   *
   * @return the bitSet
   */
  public BitSet getBitSet() {
    return this.bitSet;
  }


  /**
   * This method sets the bit at the specified index to the specified value,
   * if boolean value is true, value is added, else not added.
   *
   * @param bitIndex index
   * @param value    a boolean
   */
  public void setBit(int bitIndex, boolean value) {
    this.bitSet.set(bitIndex, value);
  }

  /**
   * Returns true if the value is present in bitSet, else returns false.
   *
   * @param value int value to check
   * @return boolean representing whether bit is 0 or 1
   */
  public boolean getBit(int value) {
    return bitSet.get(value);
  }

  /**
   * Returns the size of the BitSet.
   *
   * @return number of bits in the bitSet
   */
  public int getBitSetSize() {
    return this.m;
  }

  /**
   * Gives the probability that a false positive will occur during a query of a filter.
   *
   * @return the false positivity rate
   */
  public Double getFalsePosRate() {
    return this.r;
  }

  /**
   * Gives the maximum expected number of elements in the bloom filter.
   *
   * @return the maximum number of elements the bloom filter can take
   */
  public Integer getN() {
    return n;
  }

  /**
   * Gives the actual number of elements that were added to the bloom filter.
   *
   * @return the number of elements in the bloom filter.
   */
  public Integer getNumElements() {
    return this.numElements;
  }

  /**
   * Gives the number of hashes that must be generated for the bloom filter.
   *
   * @return the number of hash functions in the bloom filter
   */
  public Integer getNumHashes() {
    return k;
  }


  // method generated by IntelliJ

  /**
   * Method to compare two bloom filters and determine whether they are equal.
   *
   * @param o a bloom filter object
   * @return boolean representing whether two bloom filters are equal.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BloomFilter<?> that = (BloomFilter<?>) o;
    return r.equals(that.r) && n.equals(that.n) && numElements.equals(that.numElements)
        && bitSet.equals(that.bitSet) && m.equals(that.m) && k.equals(that.k);
  }

  // method generated by IntelliJ

  /**
   * Computes a hash code for a bloom filter.
   *
   * @return an integer representing the hashCode corresponding to a bloom filter.
   */
  @Override
  public int hashCode() {
    return Objects.hash(r, n, numElements, bitSet, m, k);
  }

  /**
   * Adds an element to the bloom filter, by setting the proper bits based
   * on the k hashes of the input element.
   * This method is called when the user types <code>insert_bf element</code>
   * into the command line.
   *
   * @param element to be inserted, can be of any type
   */
  public void insertElement(T element) {
    BigInteger[] hashes = createHashes(element.toString().getBytes(CHARSET), this.k);

    for (BigInteger hash : hashes) {
      this.setBit((hash.mod(BigInteger.valueOf(m))).intValue(), true);
    }
    this.numElements++;
  }

  /**
   * Adds all provided elements to the bloom filter.
   *
   * @param c a collection of elements of type T.
   */
  public void insertAll(Collection<T> c) {
    for (T element : c) {
      insertElement(element);
    }
  }


  /**
   * Queries a bloom filter and determines whether the input element might have been inserted
   * or definitely has not been inserted.
   *
   * @param element - the element to search in the bloom filter
   * @return 0: element is definitely not in the set
   * * 1: element might be in the set
   */
  public int queryElement(T element) {
    BigInteger[] hashes = createHashes(element.toString().getBytes(CHARSET), this.k);
    for (BigInteger hash : hashes) {
      if (!this.getBit((hash.mod(BigInteger.valueOf(m))).intValue())) {
        // if getBit returns false (i.e. bit is turned off)
        // we know for sure this element is not there
        return 0;
      }
    }
    // otherwise, it might be there
    return 1;
  }


  /**
   * Prints a string representation of the bloom filter.
   *
   * @return a string representing the bloom filter.
   */
  @Override
  public String toString() {
    StringBuilder bitSetString = new StringBuilder();
    for (int bitSetIndex = 0; bitSetIndex < this.getBitSetSize(); bitSetIndex++) {
      bitSetString.append(bitSet.get(bitSetIndex) ? 1 : 0);
    }
    return "BloomFilter{"
        + "r=" + r
        + ", n=" + n
        + ", bitSet=" + bitSetString
        + '}';
  }

// -------------------------------------- Stencil code ----------------------------------------- \\

  /**
   * Generates hashes based on the contents of an array of bytes, converts the result into
   * BigIntegers, and stores them in an array. The hash function is called until the required number
   * of BigIntegers are produced.
   * For each call to the hash function a salt is prepended to the data. The salt is increased by 1
   * for each call.
   *
   * @param data      input data.
   * @param numHashes number of hashes/BigIntegers to produce.
   * @return array of BigInteger hashes
   */
  public static BigInteger[] createHashes(byte[] data, int numHashes) {
    BigInteger[] result = new BigInteger[numHashes];

    int k = 0;
    BigInteger salt = BigInteger.valueOf(0);
    while (k < numHashes) {
      hashFunction.update(salt.toByteArray());
      salt = salt.add(BigInteger.valueOf(1));
      byte[] hash = hashFunction.digest(data);
      hashFunction.reset();

      // convert hash byte array to hex string, then to BigInteger
      String hexHash = bytesToHex(hash);
      result[k] = new BigInteger(hexHash, RADIX);
      k++;
    }
    return result;
  }

  /**
   * Converts a byte array to a hex string.
   * Source: https://stackoverflow.com/a/9855338
   *
   * @param bytes the byte array to convert
   * @return the hex string
   */
  private static String bytesToHex(byte[] bytes) {
    byte[] hexArray = "0123456789ABCDEF".getBytes(CHARSET);
    byte[] hexChars = new byte[bytes.length * 2];
    for (int j = 0; j < bytes.length; j++) {

      int v = bytes[j] & HEX_VALUE_255;
      hexChars[j * 2] = hexArray[v >>> 4];
      hexChars[j * 2 + 1] = hexArray[v & HEX_VALUE_15];
    }
    return new String(hexChars, CHARSET);
  }


}